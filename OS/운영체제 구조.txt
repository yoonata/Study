운영체제 구조(OS Structures)





현대의 운영체제와 같이 크고 복잡한 시스템이 적절하게 동작하고 쉽게 변경될 수 있으려면, 신중히 제작되어야 한다. 일반적인 접근방법은 한 개의 일관된 시스템보다는 할 일(task)을 작은 구성요소로 분할하는 것이다. 이들 모듈들 각각은 명확하게 정의된 시스템의 일부로서 입출력 요소나 기능이 신중하게 정의되어야 한다.







1. 간단한 구조





많은 상용 시스템들은 잘 정의된 구조를 가지고 있지 않다. 종종 이러한 운영체제들은 작고 단순하며 제한적인 시스템으로 출발하여 원래 범위 이상으로 발전한 경우이다. 그러한 시스템의 예로 MS-DOS가 있다. MS-DOS는 원래 단지 몇 사람들에 의해서 설계, 구현되었고, 이들은 MS-DOS가 그렇게 대중화 되리라고는 생각하지 못했다. MS-DOS는 최소 공간에 최대 기능들을 제공하도록 작성되어 있어서 모듈화를 위한 신중한 설계는 아니었다.







위의 이미지는 MS-DOS의 구조를 간략하게 나타내고 있다. MS-DOS는 인터페이스와 기능 계층이 잘 분리되어 있지 않다. 예를 들면, 응용 프로그램은 기본 입출력 루틴을 통하여 디스플레이와 디스크 드라이브에 직접 쓰기가 가능하다. 이러한 자유는 MS-DOS를 오류가 있는(또는 악의적인) 프로그램으로부터 취약하게 만들었다. 따라서 사용자 프로그램이 고장나면 시스템 전체가 고장나게 된다. 물론, MS-DOS는 당시의 하드웨어에 의해 제한되었다. 대상으로 하는 Intel 8088이 이중 모드와 하드웨어 보호 기능을 제공하지 않기 때문에 MS-DOS의 설계자들은 기반이 되는 하드웨어를 접근할 수 있게 방치할 수 밖에 없었다.



구조화가 잘 되어 있지 않은 또 다른 예는 최초의 UNIX 운영체제이다. UNIX는 시작부터 하드웨어 기능에 의해 제약되는 또 다른 시스템이었다. UNIX는 커널과 시스템 프로그램으로 구성되어있다. 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데, 이들은 UNIX가 발전해 오면서 오랜 기간 동안 추가되고 확장된 것이다.


 


전통적인 UNIX구조는 다음 이미지와 같이 계층들로 이루어졌다고 볼 수 있다. 시스템 호출 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널이다. 커널은 시스템 호출을 통해 파일 시스템, CPU 스케쥴링, 메모리 관리 그리고 다른 운영체제 기능을 제공한다. 요컨대, 이 커널은 하나의 계층으로 결합하기에는 엄청나게 많은 기능을 가지고 있다. 이 모놀리식(monolithic) 구조는 구현 및 유지 보수가 어려웠다.











2. 계층적 접근(Layered Approach)







적절한 하드웨어 지원이 있을 경우, 운영체제는 원래의 MS-DOS 또는 UNIX 시스템에서 허용했던 것보다 작고 보다 적절한 조각으로 분할될 수 있다. 운영체제는 컴퓨터와 그 컴퓨터를 사용하는 응용에 대해 훨씬 더 많은 제어를 유지할 수 있다.



시스템은 다양한 방식으로 모듈화 될 수 있다. 한 가지 방식은 계층적 접근방식인데, 이 방식에서는 운영체제가 여러 개의 층으로 나누어진다. 최하위 층(0층)은 하드웨어이고 최상위 층(N층)은 사용자 인터페이스이다. 다음 이미지를 보면 쉽게 이해할 수 있을 것이다.









운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체를 구현하는 층이다. 전형적으로 운영체제의 층은 자료를 저장하는 자료 구조와 상위 층에서 부를 수 있는 루틴의 집합으로 구성된다. 즉, 상위 층은 하위 층이 제공하는 연산을 호출할 수 있다.



계층적 접근방식의 주된 장점은 구현과 디버깅의 간단함에 있다. 각 층은 단지 자신보다 하위 층의 서비스와 기능(연산)들만을 사용하도록 만들어진다. 이러한 접근 방법은 시스템의 검증과 디버깅 작업을 단순화한다. 첫 번째 층은 정의에 의해 하드웨어(하드웨어는 정확하다고 가정하자)만을 사용하여 이 층의 기능을 구현하기 때문에, 나머지 시스템에 아무런 신경을 쓰지 않고 디버깅을 할 수 있다. 첫 번째 층이 끝나면 두 번째 층으로 넘어가게 되며, 이 때에는 첫 번째 층은 정확하게 동작한다고 가정할 수 있게 되기 때문에 보다 쉽게 디버깅을 할 수 있다. 즉, 이 방식을 이용하게 되면, 어느 층에서 오류가 나도, 하위의 층은 이미 문제가 없다고 판명났기 때문에 신경 쓸 필요가 없어진다. 따라서, 시스템을 계층으로 나누면 시스템의 설계나 구현이 간단해진다.


 


각 층은 자신보다 하위 수준의 층에서 제공된 연산들만 사용하여 구현한다. 각 층은 이러한 연산들이 어떻게 구현되는지 알 필요가 없다. 다만, 각 연산들이 어떤 기능을 하는지만 알면 된다. 그러므로 각 층은 특정 데이터 구조, 연산, 그리고 하드웨어의 존재를 상위 층에게 숨기게 된다. 이 과정을 추상화라고 한다. 상위의 층은 하위의 층의 기능들이 어떻게 작동하는 지는 모르지만, 그 연산들이 어떤 기능을 하는지는 알기 때문이다. 이 추상화 과정을 통해서 하위 층들의 보안을 강화할 수 있다.



계층적 접근법의 가장 어려운 점은 여러 층을 적절히 정의하는 것이다. 각 층은 자신보다 하위 계층들만 사용할 수 있기 때문에 신중한 계획이 필요하다. 예를 들면, 예비 저장장치(backing store 가상 메모리 알고리즘에 의해 사용되는 디스크 공간)를 위한 장치 드라이버는 메모리 관리 기능보다 하위 층에 있어야 한다.



계층적 구현방법의 또다른 문제점으로는 다른 유형의 구현방법보다 비효율적이라는 것이다. 사용자 층에서부터 하드웨어 층까지 내려가면서 사용되는 매개변수의 수와 종류도 다양할 것이라는 점은 누가 보더라도 명확하다. 게다가, 각 층은 시스템 호풀에 오버헤드를 추가하게 될 것이다. 그 결과, 계층적 구조가 아닌 시스템보다 시스템 호출의 실행 시간이 더 길어지게 된다.









3. 마이크로커널(Microkernels)





UNIX가 확장함에 따라 커널이 커지고 관리하기 어려워졌다. 이에 대한 해결책으로 많은 운영체제들이 사용하고 있는 방식이 바로 마이크로커널이다. 마이크로커널 방식은 모든 필수적이지 않은 구성요소를 커널로부터 제거하고, 그들을 시스템 및 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다. 여기서 어느 작업이 필수적이고 어느 작업이 사용자 공간에 구현되어야 하는지에 대해서는 2018년 현재까지도 의견이 일치하지 않고 있다. 그러나 통상 마이크로커널은 통신설비 외에 추가로 최소한의 프로세스와 메모리 관리를 제공한다.



마이크로커널의 주 기능은 클라이언트 프로그램과 사용자 공간에서 실행되는 다양한 서비스 간에 통신설비를 제공하는 것이다. 예를 들면, 클라이언트 프로그램이 파일을 접근하기를 원하는 경우, 파일 서버와 반드시 상호작용해야 한다. 클라이언트 프로그램과 서비스는 결코 직접 상호작용하지 않는다. 오히려, 그들은 마이크로커널과 메시지를 교환함으로써 간접적으로 상호작용한다.


 


마이크로커널 접근법의 장점은 운영체제의 확장이 용이하다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널의 변경을 필요로 하지 않는다. 커널이 변경되어야 할 때는 마이크로커널이 작은 커널이기 때문에 변경할 대상이 비교적 적다고 할 수 있다. 이 접근법에 의해 개발된 운영체제는 한 하드웨어로부터 다른 하드웨어로 이식이 쉽다.



마이크로커널은 대부분의 서비스가 커널이 아니라 사용자 프로세스로 실행되기 때문에 보다 높은 보안성과 신뢰성도 제공한다. 만일 한 서비스가 잘못 되더라도 운영체제의 다른 부분에는 영향을 주지 않기 때문이다.



이러한 마이크로커널에도 치명적인 단점이 존재한다. 그것은 바로, 가중된 시스템 동작 오버헤드에 의한 시스템 성능의 감소이다.









4. 모듈화 커널 (Modular Kernel)





또다른 운영체제 구조로는, 객체지향 프로그래밍 기법을 사용하는 모듈화 커널이 있다. 이 커널은 부팅 중 혹은 실행 중에 부가적인 서비스들을 링크한다. 이러한 전략은 동적 적재 모듈을 사용하며, Solaris, Linux 및 Mac OS X 등의 현대 UNIX 구현에 일반적이 추세이다.



예를 들어, Solaris 운영체제 구조는 핵심 커널과 7가지 유형의 적재 가능 커널 모듈로 구성된다.



- 스케줄링 클래스

- 파일 시스템

- 적재가능 시스템 호출

- 실행 파일 형식

- STREAMS 모듈

- 기타 잡다한 기능들

- 장치 및 버스 드라이버







이러한 설계는 핵심 서비스를 제공할 뿐만 아니라 특정 기능들을 동적으로 구현할 수 있게 한다. 예를 들어, 특정 하드웨어를 위한 장치와 버스 드라이버는 커널에 추가될 수 있고 다른 파일 시스템도 적재가능 모듈 형태로 추가될 수 있다. 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층적 구조와 닮았다. 그러나, 모듈은 임의의 모듈을 호출할 수 있다는 점에서 계층적 구조보다 유연하다고 할 수 있다. 게다가 중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재방법과 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로커널과 유사하다. 그러나 통신을 위한 메시지 전달이 불필요하기 때문에 더 효율적이라고 할 수 있다.











5. 혼성 구조(Hybrid Systems)







애플의 Mac OS X(Darwin 이라고도 불린다) 운영체제는 혼성 구조를 사용한다. 이 운영체제는 기본적으로 계층구조를 사용하고 있는데, 그 중 한 층이 Mach 마이크로커널로 구성된다. OS X의 구조는 다음과 같다.







또다른 혼성 구조의 운영체제로는 구글의 안드로이드가 있다.







