운영체제 설계 및 구현 (OS Design and Implementation)







1. 운영체제 설계 목표 (Design Goals)





시스템을 설계하는 데에 첫번째 문제점은 시스템의 목표와 명세를 정의하는 일이다.



시스템 설계는 최상위 수준에서 하드웨어와 시스템 유형(일괄처리, 시분할, 단일 사용자, 다중 사용자, 분산, 실시간 혹은 범용)의 선택에 의해 영향을 받을 것이다. 이 최상위 설계 수준을 넘어서면 요구 조건들을 명세 하는 것이 훨씬 더 어렵다. 그러나, 이러한 요구 조건은 근본적으로 사용자 목적과 시스템 목적이라는 두가지 그룹으로 나눌 수 있다.



사용자들은 시스템이 명백한 특성을 가지기를 원한다. 시스템이 사용하기 쉽고 편리하며, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 한다. 물론, 이러한 명세는 어떻게 이러한 목적을 달성할 것인가에 대한 일반적인 합의가 없기 때문에 시스템 설계에 있어 특별히 유용하지는 않다.



개발자의 입장에서 보자면, 운영체제는 설계, 구현 유지 및 보수가 쉬워야 한다. 또한, 적응성, 신뢰성, 효율성을 가지고 있어야 하며, 오류가 없어야 한다. 그러나, 이러한 조건들 역시 앞서 언급한 것들과 마찬가지로 명확하지 않고 애매하다.



요약하면, 운영체제에 대한 요구를 정의하는 유일한 해법은 없다. 즉, 운영체제의 설계 목표는 정해져 있는 것이 아니라, 정해나가는 것이다. 운영체제의 명세와 설계는 매우 창조적인 일이다. 어떤 교재도 이런 문제점을 해결하는 방법을 알려 줄 수는 없더라도, 소프트웨어 공학 분야에서 일반적인 원칙이 개발되었다.









2. 메케니즘과 정책(Mechanisms and Policies)





한 가지 중요한 원칙은 메커니즘(mechanism)으로부터 정책을 분리하는 것이다. 메커니즘은 어떤 일을 어떻게 할 것인가를 결정하는 것이고, 정책은 무엇을 할 것인가를 결정하는 것이다. 예를 들면, 타이머를 통한 인터럽트 발생 구조는 CPU 보호를 보장하기 위한 메커니즘이지만, 특정 사용자를 위해 타이머를 얼마나 오랫동안 설정할 지를 결정하는 것은 정책적 결정이다.



정책과 메커니즘의 분리는 융통성을 위해 매우 중요하다. 정책은 장소가 바뀌거나 시간의 흐름에 따라 변경될 수 있다. 최악의 경우, 정책의 변경이 저변에 깔려 있는 메커니즘의 변경을 요구하게 된다. 정책의 변경에 민감하지 않은 일반적인 메커니즘이 보다 바람직하다. 그렇게 되면, 개발자의 입장에서 유지 및 보수가 더욱 쉬워질 것이 명확하기 때문이다.


 


정리하자면, 무엇(what)을 할지를 결정하는 것이 정책이라면, 어떻게(how)하느냐를 결정하는 것이 메커니즘이다.







3. 구현(Implementation)





운영체제 설계가 끝나면 구현을 해야 할 것이다. 초기의 운영체제들은 어셈블리어로 작성되었지만, 현대의 대부분의 운영체제들은 C나 C++와 같은 고급 언어로 작성된다.



운영체제를 고급 언어로 구현하는 것에 대해 생각할 수 있는 유일한 단점은 속도가 느리고 저장장치가 많이 소요되는 것이다. 그러나 이것은 현재 시스템에서는 더 이상 주요 문제가 되지 않는다. 전문적인 어셈블리어 프로그래머는 효율적인 작은 루틴을 생산할 수 있을지라도 대규모 프로그램에 대해서는 현대의 컴파일러가 복잡한 분석을 실행하고, 정교한 최적화를 적용하여 우수한 코드를 생산할 수 있다. 현재의 처리기는 깊은 파이프라이닝과 다수의 연산장치를 가지며 이들 연산장치는 복잡한 연산을 인간이 할 수 있는 것보다 훨씬 쉽게 처리할 수 있다.


 


다른 시스템에서도 알려진 사실이지만, 운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는 좋은 자료구조와 알고리즘으로부터 기인할 가능성이 높다. 게다가, 운영체제가 크긴 하지만, 단지 소량의 코드만이 고성능에 필수적이다. 아마도 메모리 관리자와 CPU 스케쥴러가 가장 중요한 루틴일 것이다. 시스템이 작성되어 정확히 작동하면, 병목 루틴을 확인할 수 있고, 동등한 어셈블리어로 대체될 수 있다.



병목을 찾아내기 위해서는 시스템의 성능을 감시할 수 있어야 한다. 시스템 행동(System behavior)에 대한 측정을 계산하고 보여 줄 수 있는 코드가 추가되어야 한다. 많은 시스템에서 운영체제는 시스템 행동의 추적 리스팅(trace listing)을 생성함으로써 이러한 일을 할 수 있다. 모든 주목할 만한 사건들이 그들의 시간과 중요한 매개변수들과 함께 파일에 기록된다. 나중에 분석 프로그램이 로그 파일을 처리해 시스템 성능을 결정하고, 병목과 비효율성을 확인한다. 또한, 이 추적 결과는 제안된 개선 시스템에 대한 모의실험을 위한 자료로 사용할 수도 있다.


