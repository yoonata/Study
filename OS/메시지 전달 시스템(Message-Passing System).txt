메시지 전달 시스템 (Message-Passing System)



메시지 전달 시스템 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다. 메시지 전달방식은 통신하는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다.



메시지 전달 시스템은 최소한 두 가지 연산(send와 receive)을 제공한다. 프로세스가 보낸 메시지는 고정 길이일 수도 있고 가변 길이일 수도 있다. 고정 길이 메시지만 보낼 수 있다면, 시스템 수준의 구현은 간단하다. 그렇지만, 이러한 제한은 프로그래밍 작업을 더욱 힘들게 한다. 반면에, 가변 길이 메시지는 보다 복잡한 시스템 수준의 구현을 필요로 하지만, 프로그래밍 작업은 간단해진다.





하나의 링크(메시지 전달 링크)와 send/receive 연산을 논리적으로(물리적 구현 부분(공유 메모리, 하드웨어 버스, 네트워크 등)을 제외한 나머지) 구현하는 방법들은 다음과 같다.



- 직접 또는 간접 통신



- 동기식 또는 비동기식 통신



- 자동 또는 명시적 버퍼링











1. 명명 (Naming)



통신을 원하는 프로세스들은 서로를 가리킬 수 있는 방법이 있어야 한다. 프로세스들은 간접 통신 또는 직접 통신을 사용할 수 있다.



직접 통신을 하기 위해서는 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다. 이 기법에서 send와 receive 프리미티브들은 다음과 같이 정의된다.



- send(P, message) : 프로세스 P에게 메시지를 전송한다

- receive(Q, message) : 프로세스 Q로부터 메시지를 수신한다



이 기법에서 통신 연결은 다음과 같은 특성을 가진다



- 통신을 원하는 두 프로세스 사이에 연결이 자동적으로 구축된다. 프로세스들은 통신하기 위해 서로 상대방의 신원(identification)만 알면 된다.



- 연결은 정확히 두 프로세스 사이에만 이루어진다.



- 통신하는 한 쌍의 프로세스 사이에는 정확하게 하나의 연결이 존재해야 한다.



이 기법은 주소 방식에서 대칭성을 보인다. 즉, 송신자와 수신자 프로세스가 모두 통신하려면 상대방의 이름을 제시해야 한다. 이 기법의 변형으로서 주소 지정 시 비대칭 형식을 사용할 수도 있다. 이 비대칭 직접 통신 기법은 송신자는 수신자를 명시하지만, 수신자는 송신자에 대해서 명시할 필요가 없다. 다시 말해, 수신자가 송신자에 대해서 자세히 알 필요가 없는 경우에 이 비대칭 직접 통신 기법이 사용된다. 비대칭 직접 통신 기법의 경우 send와 receive 프리미티브들은 다음과 같이 정의된다.



- send(P, message) : 메시지를 프로세스 P에 전송한다.

- receive(id, message): 임의의 프로세스로부터 메시지를 수신한다. 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다.



이들 기법(대칭적 그리고 비대칭적) 모두의 단점은 프로세스를 정확히 지정함으로써 모듈화를 제한한다는 것이다. 만약 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정 부분을 검사할 필요가 있다. 옛 이름들에 대한 모든 참조를 찾아서 새로운 이름으로 변경해야만 한다. 이렇게 프로세스의 신원을 명시적으로 표기하는 방식과 같은 하드 코딩(hard-coding) 기법은 간접적 통신 기법에 비해 바람직하지 않다.


 




간접 통신에서 메시지들은 메일박스(mailbox) 또는 포트(port)로 송신되고, 메일박스나 포트로부터 수신된다. 메일박스는 추상적으로 프로세스들이 메시지를 넣고, 메시지들이 제거될 수 있는 객체라고 볼 수 있다. 각 프로세스는 고유의 메일박스를 정의하여 생성하게 된다. 각 메일박스는 고유의 식별자를 가진다. 예를 들어, POSIX 메시지 큐는 메일박스를 식별하기 위하여 정수값을 사용한다. 이 메일박스 기법의 경우 send와 receive 프리미티브들은 다음과 같이 정의된다.



- send(A, message) : 메시지를 메일박스 A로 송신한다.

- receive(A, message) : 메시지를 메일박스 A로부터 수신한다.



이 방법에서 통신 연결은 다음의 성질을 가진다.



- 한 쌍의 프로세스 사이의 연결은 프로세스들이 공유 메일박스를 가질 때만 구축된다.



- 연결은 두 개 이상의 프로세스들과 연관될 수 있다.



- 통신하고 있는 각 프로세스들 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결마다 하나의 메일박스가 할당된다.





메일박스는 한 프로세스 또는 운영체제가 소유주가 된다. 프로세스가 메일박스를 소유한 경우(즉, 메일박스가 프로세스의 주소 공간의 일부에 해당되는 경우), 우리는 소유자(이 메일박스로부터 메시지를 수신할 수만 있는 프로세스)와 메일박스의 사용자(메일박스에 메시지를 송신만 할 수 있는 프로세스)를 구분할 수 있다. 각 메일박스가 유일한 소유주를 가지고 있기 때문에 이 메일박스로 보내진 메시지를 누가 수신할 지에 대한 혼란은 없다. 메일박스를 소유하고 있는 프로세스가 종료할 때 메일박스는 사라진다. 그 후에 이 메일박스로 메시지를 송신하는 모든 프로세스는 이 메일박스가 더 이상 존재하지 않는다는 사실을 반드시 통보 받아야 한다.


 


반면에, 운영체제가 소유한 메일박스는 자체적으로 존재한다. 이러한 메일박스는 독립적인 것으로 어떤 특정한 프로세스에 예속되지 않는다.


 


운영체제는 프로세스가 다음과 같은 작업을 할 수 있도록 하는 메커니즘을 반드시 제공해야 한다.



- 새로운 메일박스를 생성한다.



- 메일박스를 통해 메시지를 송신하고 수신한다.



- 메일박스를 삭제한다.



새로운 메일박스를 생성하는 프로세스는 디폴트로 메일박스의 소유자가 된다. 초기에는 소유자만이 이 메일박스를 통해 메시지를 수신할 수 있는 유일한 프로세스이다. 그러나 소유권과 수신 특권은 적절한 시스템 호출을 통해 다른 프로세스에게 전달될 수 있다. 물론 이런 권리 전달은 메일박스의 수신자가 여럿이 되게 한다.











2. 동기화 (Synchronization)



프로세스간의 통신은 send와 receive 프리미티브를 호출함으로써 발생한다. 각 프리미티브를 구현하기 위한 여러 설계 옵션이 존재한다. 메시지 전달은 봉쇄형(blocking - 비동기식)이거나 비봉쇄형(non-blocking - 동기식)이다.



- 봉쇄형 송신:

송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 봉쇄된다.



- 비봉쇄형 송신:

송신하는 프로세스는 메시지를 보내고 작업을 재시작한다.



- 봉쇄형 수신:

메시지가 이용 가능할 때까지 수신 프로세스는 봉쇄된다.



- 비봉쇄형 수신:

송신하는 프로세스는 유효한 메시지 또는 널(null)을 받는다.











3. 버퍼링 (Buffering)



통신이 직접적이든 간접적이든 간에 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어 있다. 기본적으로 이러한 큐를 구현하는 방식은 세 가지가 있다.



- 무용량 (zero capacity):



큐의 최대 길이가 0이다. 즉, 연결 자체 안에 대기하는 메시지들을 가질 수 없다. 이 경우에 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.



- 유한 용량 (bounded):



큐는 유한한 길이 n을 가진다. 즉, 최대 n개의 메시지가 그 안에 들어 있을 수 있다. 새로운 메시지가 전송될 때 큐가 만원이 아니라면, 메시지는 큐에 놓이며(메시지가 복사되든지 또는 메시지에 대한 포인터가 유지된다), 송신자는 대기하지 않고 실행을 계속한다. 그렇지만 연결은 유한한 용량을 가진다. 연결이 만원이면, 송신자는 큐 안에 가용한 공간이 생길 때까지 반드시 봉쇄되어야 한다.



- 무한 용량 (unbounded capacity):



큐는 잠재적으로 무한한 길이를 가진다. 따라서 메시지들이 얼마든지 큐 안에서 대기할 수 있다. 송신자는 결코 봉쇄되지 않는다.





무용량의 경우는 때로 버퍼링하지 않는 메시지 시스템이라고 부른다. 다른 경우들은 자동 버퍼링 메시지 시스템이라 불린다.

