세그멘테이션 (Segmentation)







페이징 기법은 페이지라는 단위로 메모리를 일정한 간격으로 자르는 방식으로 메모리를 관리한다. 하지만 프로세스를 물리적인 단위인 페이지 말고 논리적 내용 단위인 세그먼트로 자를 수 있는 세그먼테이션 방법이 있다. 예를 들면 우리가 돼지를 잡아서 보관을 한다고 생각해보자. 페이징의 방법을 사용하면 돼지를 모두 같은 단위로 잘라서 보관을 하는 것이다. 반면에 세그먼테이션은 부위별로 다른 크기로 잘라서 보관하는 것이다.



(페이징 관련 내용: <http://neos518.tistory.com/124?category=806096>)


 




세그멘테이션은 프로세스를 세그먼트의 집합으로 생각한다. 사실 하나의 프로세스가 동작하려면 기본적으로 "코드, 데이터, 그리고 스택" 이 세 가지의 세그먼트는 항상 가지고 있다. 추가로, 프로그램의 시작점이라고 할 수 있는 main 함수가 있을 수 있고, 다른 함수들이 있을 수도 있다. 데이터의 경우에도, 어떤 구조체가 있을 수도 있고 배열도 있을 수 있다. 그래서 세그먼테이션은 물리적인 크기의 단위가 아닌 논리적 내용의 단위(크기가 아닌 의미가 같은 단위)로 자르기 때문에 세그먼트들의 크기는 일반적으로 같지 않다.



프로세스를 어떻게 자르는가에 대한 방법 빼고 메모리에 할당하는 방법에 대해서는 페이징과 방법이 같다. MMU(Memory Management Unit - 메모리 관리 유닛) 내의 재배치 레지스터를 이용하여 논리 주소를 물리 주소로 바꾸어 주는 방식을 취한다. MMU는 세그먼트 테이블로 CPU에서 할당한 논리 주소에 해당하는 물리 주소의 위치를 가지고 있다. 이 방법을 이용하면 CPU는 프로세스가 연속된 메모리 공간에 위치한다고 착각을 하게 된다. 아래의 이미지가 이 과정을 보여주고 있다.













이때, 주소를 변환하는 방법 역시 같다. 하지만 논리 주소에서 보내는 주소 값에서 하위 변위 비트를 제외한 앞의 비트들은 페이징 번호가 아니라 세그먼트 번호가 되는 것이다. 따라서 논리 주소는 세그먼트 번호와 변위 비트로 이루어져 있게 된다. 세그먼트 테이블에 논리 주소 값이 들어가게 되면 세그먼트 번호는 세그먼트 테이블의 인덱스 값으로 인식을 하게 된다. 세그먼트 번호를 토대로 테이블 내용으로 들어가 시작 위치 및 한계 값을 파악한다. 물리 주소는 세그먼트 테이블에 있는 시작 위치와 변위 값을 합하여 구할 수 있다. 그런데 이런 주소 값이 한계(각 세그먼트의 크기)를 넘어서면 "segment violation"이라는 예외 상황 처리를 하게 된다. 이는 변위가 한계보다 크면 발생한다.





세그먼테이션의 경우에도 보호와 공유의 기능을 수행하고 있다. 모든 논리 주소들은 세그먼테이션 테이블을 경유하게 되므로 세그먼트 테이블 엔트리마다 r, w, x 비트를 만들어 해당 세그먼트에 대한 접근 제어를 가능하게 해준다. 또한, 여러 개의 프로세스가 동일한 코드를 사용한다면, 해당 코드를 메모리에 한번 적재한 뒤, 각 프로세스의 세그먼트 테이블의 해당 코드 영역이 같은 곳을 가리키게 만든다.


 


그런데 위와 같은 기능이 페이징의 기법보다 더 좋다고 할 수 있다. 왜냐하면, 페이징은 프로세스를 같은 단위로 자르게 되므로 중요한 부분과 중요하지 않은 부분이 같은 페이지 안에 할당될 수가 있기 때문이다. 게다가, 코드 영역이 같은 단위로 잘리기 때문에 애매하게 잘려질 확률이 있다.



이에 반해, 세그먼테이션의 방법으로 자르게 되면 코드 영역은 코드 영역으로 잘리게 되고 중요한 세그먼트, 중요하지 않은 세그먼트를 논리적인 내용 측면으로 자를 수 있다. 그렇게 되면 보호와 공유의 기능을 수행하기 쉬워지는 것이다. 내용적인 측면으로 다 나누어 졌기 때문이다.





이렇게 놓고 보면 세그멘테이션만을 사용해야 할 것 같아 보인다. 하지만, 세그멘테이션 방식 역시 단점이 존재한다. 세그먼트는 크기가 고정되어 있지 않고 가변적이다. 자르는 단위가 물리적인 단위가 아닌 논리적인 단위이기 때문이다. 물리적인 크기가 다른 각 세그먼트를 메모리에 두려면 동적 메모리 할당을 해야 한다. 이때, 외부 단편화가 발생할 수 있다.


 


이에 따라, 세그먼트를 페이징하는 방법이 고안되었다. 즉, 세그멘테이션과 페이징 기법을 함께 사용함으로써 각자의 단점을 가리고 장점을 극대화시키는 것이다.









우선, 프로세스를 세그먼트 단위로 자른다. 이대로 사용하면 앞서 언급한 것처럼 외부 단편화가 발생할 수 있다. 따라서, 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 사용한다. 이 방식으로 메모리에 적재하면 각 세그먼트가 페이징에 의해 일정 단위로 다시 잘렸기 때문에 외부 단편화의 발생을 막을 수 있다.





이 방식의 가장 큰 단점이라면, 세그먼트 테이블과 페이지 테이블을 차례로 거치기 때문에 일반적인 페이징이나 세그멘테이션에 비해 속도가 느려지게 된다.


