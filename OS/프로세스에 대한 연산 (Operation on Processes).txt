프로세스에 대한 연산 (Operation on Processes)



대부분의 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고 제거 되어야 한다.







1. 프로세스 생성 (Process Creation)



프로세스는 실행 도중에 프로세스 생성 시스템 호출을 통하여 여러 개의 새로운 프로세스를 생성한다.



생성하는 프로세스를 부모 프로세스 생성되는 프로세스를 자식 프로세스라고 한다.




이 결과, 프로세스 트리를 형성한다.









현대 운영체제들은 프로세스 식별자(pid - process id)를 통해서 프로세스를 구분한다. 이때, 이 식별자는 통상적으로 정수이다.





일반적으로, 프로세스가 자신의 임무를 달성하기 위해서는 자원(CPU 시간, 메모리, 파일, 입출력장치)이 필요하다. 프로세스가 서브프로세스를 생성할 때 운영체제로부터 직접 자원을 얻을 수 있거나, 부모 프로세스 자원의 부분 집합만을 사용하도록 제한받을 수 있다. 부모 프로세스는 자원을 자식들에게 분할하여 나누어 주거나, 또는 여러 자식들과 일부 자원(메모리나 파일과 같은)을 공유할 수도 있다.


 


자식 프로세스가 부모 프로세스 자원의 일부만을 사용하도록 제한하면, 임의의 프로세스가 너무 많은 서브 프로세스들을 만들어 시스템이 과부하 되는 것을 방지할 수 있다.





프로세스가 새로운 프로세스를 생성할 때 실행과 관련하여 두 가지 가능성이 있다.



1) 부모가 계속해서 자식과 병렬로 실행된다.



2) 부모가 모든 자식 또는 일부 자식이 끝날 때까지 기다린다.





새로운 프로세스들의 주소 공간 측면에서 볼 때 다음과 같은 두 가지 가능성이 있다.



1) 자식 프로세스는 부모 프로세스의 복사본이다 (자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다)



2) 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가진다.



이 차이점을 설명하기 위해서 UNIX 운영체제를 고려해 보자. UNIX에서 각 프로세스는 프로세스 식별자로 식별되는데, 이것은 고유한 정수이다. 새로운 프로세스는 fork() 시스템 호출로 생성된다. 새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다. 이 메커니즘은 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다. 두 개의 프로세스(부모와 자식)들은 fork() 후의 명령어에서부터 실행을 계속하며, 이때 한 가지 다른 점은 fork()의 반환 코드가 서로 다르다는 것이다. 자식 프로세스의 식별자(0이 아닌 값)가 부모에게 반환된다. 이에 반해 새로운 프로세스(자식 프로세스)에게는 0이 반환된다.



전형적으로, fork() 시스템 호출 후에 두 프로세스 중 하나가 자신의 메모리 공간을 새로운 프로그램으로 바꾸기 위해서 exec() 시스템 호출이 사용된다. exec()은 이진 파일을 메모리로 적재하고(이때 exec() 시스템 호출은 원래 프로그램의 메모리 이미지를 파괴한다) 프로그램의 실행을 시작한다.


 


부모 프로세스는 하나 이상의 자식을 생성할 수 있으며, 자식 프로세스가 모두 종료될 때까지 기다리기 위해서 wait() 시스템 호출을 사용한다. 이 경우, 준비완료 큐에서 부모 프로세스가 제거되어지며, 모든 자식 프로세스들이 끝난 뒤에 부모 프로세스가 다시 준비완료 큐에 추가된다.







2. 프로세스 종료 (Process Termination)



마지막 문장의 실행을 끝내고 Exit 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청할 경우 종료한다.



통상적으로 프로세스 종료 시 프로세스는 자신의 부모에게 wait() 시스템 호출을 통해 상태 값을 반환한다. 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 운영체제에게 반납된다.


 


부모 프로세스는 다음과 같이 여러 가지 이유로 인하여 자식들 중 하나의 실행을 종료할 수 있다.


 


1) 자식 프로세스가 자신에게 할당된 자원을 초과하여 사용할 때는 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야 한다.



2) 자식에게 할당된 임무(task)가 더 이상 필요 없게 되었을 때



3) 운영체제가 부모가 종료한 후에 자식이 남아 실행되는 것을 허용하지 않는 경우





일반적으로, 부모 프로세스가 종료한 이후에 자식 프로세스는 더 이상 존재하지 못한다. 즉, 프로세스가 종료되면(정상적이든 비정상적이든) 그로부터 비롯된 모든 자식 프로세스들도 종료되어야 한다. 이것을 연속적 종료(cascading termination)라고 부르며, 이 작업은 운영체제에 의해 시작된다.



프로세스 실행과 종료를 설명하기 위해서 UNIX에서는 exit() 시스템 호출을 사용하여 프로세스를 종료시킬 수 있고, 부모 프로세스는 wait() 호출을 사용해서 자식 프로세스의 종료를 기다릴 수 있다. wait() 시스템 호출은 부모가 여러 자식들 중에서 어느 프로세스가 종료되었는지 알 수 있도록 종료된 자식의 프로세스 식별자를 돌려준다. 그러나, 부모가 먼저 종료되면 모든 자식은 init 프로세스를 그들의 새로운 부모로 지정 받는다. 따라서, 자식들은 여전히 그들의 상태와 실행 통계를 수집할 부모를 가지게 된다.



