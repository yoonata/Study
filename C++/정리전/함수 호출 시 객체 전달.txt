- 값에 의한 호출과 주소에 의한 호출의 특징
값에 의한 호출(call by value)은 실인자의 값을 복사하여 전달하므로, 함수 내에서 실인자를 손상시킬 수 없는 장점이 있다. 그러므로 함수 호출에 따른 부작용(side-effect)은 없다. 반면, 주소에 의한 호출(call by pointer)은 실이자의 주소를 넘겨주어 의도적으로 함수 내에서 실인자의 값을 변경하고자 할 때 이용된다. C++에서는 이들 외에 참조에 의한 호출(call by reference)을 추가하였다.

1. 함수 호출시 객체 전달
C++에서는 함수의 객체를 전달할 수 있으며, 이것은 int, char등 기본 타입의 값을 전달하는 것과 여러 가지 면에서 다르다.
1) 값에 의한 호출로 객체 전달
- 값에 의한 호출 과정
값에 의한 호출로 객체를 전달하게 되면 실인자 객체를 복사해서 함수의 인자로 전달을 한다. 따라서, 실인자 객체는 해당 함수의 영향을 받지 않게 된다.
- 값에 의해 호출 시 객체 복사 시간
값에 의한 호출은 함수 안에서 매개 변수 객체에 어떤 변화가 일어나도 실인자(원본 객체)를 훼손시키지 않는 장점이 있다. 다만,실인자 객체의 크기가 크면 객체를 복사하는 시간이 커지는 단점이 있다.
- 값에 의한 호출로 객체를 전달할 때 문제점
값에 의한 호출로 객체를 전달하면 표면적으로는 나타나지 않는 약간의 문제가 수반된다. 이 문제는 C++ 언어의 다른 요소와 관계되어 있기 때문에 알고 넘어가는 것이 좋을 듯하다.
객체가 함수에 전달되면, 함수의 매개 변수 객체가 생성되고, 함수가 종료하면 매개 변수 객체가 소멸된다. 이때 매개 변수 객체의 생성자와 소멸자가 모두 실행되는가? 답부터 말하면 '아니다'이다. 객체를 매개 변수로 가지는 함수의 경우,  C++ 컴파일러는 매개 변수 객체의 생성자는 실행되지 않고 소멸자만 실행되도록 컴파일 한다.
- 왜 매개 변수 객체의 생성자가 실행되지 않도록 컴파일 되는가?
매개 변수 객체의 생성자가 실행되지 않고 소멸자만 실행되는 비대칭 구조는, 함수 호출 시 원본 객체의 상태를 그대로 매개 변수 객체에 전달되도록 하기 위한 것이다.
- 복사 생성자
값에 의한 호출 시 컴파일러는 매개 변수 객체의 생성자 대신 복사 생성자(copy constructor)가 호출되도록 컴파일하기 때문에, 생성자가 ㅣㅅㄹ해되지 않는 것이다. 컴파일러는 클래스에 복사 생성자가 작성되어 있지 않는 경우, 실인자 객체의 멤버 변수를 1:1로 매개 변수 객체에 복사하는 디폴트 복사 생성자를 자동으로 삽입하다.
2) 주소에 의한 호출로 객체 전달
주소에 의한 호출 방식으로 함수를 작성하면 값에 의한 호출 시 생성자가 실행되지 않는 것으로 인한 염려에서 벗어날 수 있다.
- 주소에 의한 호출 과정
값에 의한 호출에서는 객체나 자료의 값을 복사해서 인자로 전달을 했지만, 주소에 의한 호출에서는 실인자의 주소값을 복사해서 함수의 인자로 전달한다.
- 주소에 의한 호출의 특징
객체의 주소를 전달하는 방식은 원본 객체를 통째로 전달하는 값에 의한 호출에 비해 원본 객체를 복사하는 시간 소모가 없으며, 매개 변수가 단순 포인터이므로, 값에 의한 호출 시에 발생하는 생성자 소멸자의 비대칭 문제도 없다. 하지만, 매개 변수 포인터로 의도하지 않게 원본 객체를 훼손할 가능성이 있기 때문에 코딩에 조심해야 한다.



