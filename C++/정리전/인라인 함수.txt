1. 함수 호출에 따른 시간 오버헤드

함수는 초기 컴퓨터 언어의 발달사에서 획기적인 발명품이었다. 적절한 단위 작업을 하나의 함수로 작성하여 두고 필요할 때마다 호출하여 실행할 수 있으므로, 함수는 프로그램을 구성하는 빌딩 블록(building block)의 역할을 하여 왔다. 개발자들은 늘 프로그램 코드를 어떻게 쪼개서 함수들로 만들지 궁리한다. 그러나 함수의 호출에는 대가가 따른다. 함수 호출과 실행을 마치고 돌아오는 과정에서 시간 소모가 발생한다.
함수 호출 오버헤드(overhead) 시간이 무시할 수 없는 비중을 파지하는 경우도 있다. 다음 예제 코드의 경우 1에서 10000까지 루프를 돌면서 홀수 합을 구하는 코드로서, 함수 호출에 따른 시간 오버헤드의 심각성을 보여준다.
#include <iostream>
using namespace std;
int odd(int x) {
return (x%2);
}
int main() {
int sum = 0;
//1에서 10000까지의 홀수의 합을 계산
for (int i = 0; i <= 10000; i++) {
if (odd(i))
sum += i;
}
cout << sum << endl;
}
위의 코드에서 odd() 함수의 코드 x%2를 계산하는 시간보다, odd() 함수의 호출과 리턴에 따른 오버헤드 시간이 더 크다. 그것도 10000번이나 odd() 함수를 호출하기 때문에 함수 호출 오버헤드는 더욱 가중된다. x%2 계산을 함수로 만든 것은 잘못된 판단이다. 이처럼, 짧은 코드를 함수로 만들면, 함수 호출의 오버헤드가 상대적으로 커서 프로그램 실행 시간이 길어지는 원인이 된다. 짧은 코드로 이루어진 이러한 함수에 대해 호출 오버헤드를 줄일 방법이 있으면 프로그램의 실행 속도를 개선할 수 있을 것이다.

2. 인라인 함수(inline function)
인라인 함수란 짧은 코드로 구성된 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 C++에서 도입된 방법이다. 인라인 함수는 함수 앞에 inline 키워드를 이용하여 다음과 같이 선언한다.
inline int odd(int x) {
return (x%2);
}
컴파일러는 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입하여 함수 호출이 일어나지 않게 한다. 이렇게 되면, 함수 호출 오버헤드가 없어지기 때문에 실행 속도가 빨라진다.
- 인라인 함수의 장단점
대부분의 객체 지향 언어에서와 같이 C++ 프로그램 역시 비교적 작음 함수를 많이 만들게 된다. C++에서는 멤버 변수의 값을 알아내고 멤버 변수에 값을 쓰는 이른바 getter/setter라고 불리는 작은 함수들이 많이 존재하며, 이 함수들을 호출하는 코드 역시 많이 존재한다. 이런 작은 함수를 인라인으로 선언하면 C++ 프로그램의 실행 속도를 향상시킬 수 있다. 그러나 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 단순 삽입하므로, 호출하는 곳이 여러 군데 있으면 그 만큼 전체 크기가 늘어나는 단점이 있다. 가능한 작은 함수를 인라인으로 선언하는 것이 현명하다.
- 인라인 함수의 제약 사항
생성자를 포함하여 클래스의 모든 멤버 함수가 인라인으로 선언될 수 있다. 만약 생성자나 멤버 함수의 크기가 작은 경우, 클래스 선언부에 멤버 함수나 생성자를 직접 구현하여도 무방하다. 이 경우, 구현된 생성자나 멤버 함수는 컴파일러에 의해 인라인 함수로 자동 처리된다.



