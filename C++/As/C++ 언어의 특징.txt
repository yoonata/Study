1. C++ 언어의 설계 목표

C++ 언어의 기본적인 설계 목표에 대해서 알아보자.

1) C 언어로 작성된 프로그램과의 호환성(compatbility)을 유지한다. 
기존에 작성된 C 프로그램을 그대로 사용할 수 있도록 C 언어의 문법적 체계를 그대로 계승한다. 
또한, C 언어로 작성되어 컴파일된 목적 파일(object file)이나 라이브러리를 C++ 프로그램에서 링크하여 사용할 수 있도록 한다.
2) 소프트웨어의 재사용을 통해 소프트웨어 생산성을 높이고, 복잡하고 큰 규모의 소프트웨어 작성, 관리, 유지 보수를 쉽게 하기 위해서 데이터 캡슐화, 상속, 다형성 등의 객체 지향적 개념을 도입한다.
3) 타입 체크를 엄격히 하여 실행 시간 오류의 가능성을 줄이고 디버깅을 돕는다.
4) 실행 시간의 효율성 저하를 최소화한다.
객체 지향 개념의 도입으로 멤버 함수의 호출이 잦아지고 이로 인해 발생하는 실행 시간 저하의 비효율성을 막기 위해 인라인 함수의 도입 등 합수 호출로 인한 시간 저하를 막는다.

2. C 언어에 추가한 기능

C++ 언어는 C 언어의 문법적 규칙을 그대로 승계하며, 프로그래밍의 편리와 다양성을 위해 다음과 같은 기능을 추가하였다.
- 인라인 함수 (inline function) :
자주 호출되는 함수의 경우, 함수 호출 대신 함수 코드를 확장 삽입하는 방식이며, 실행 시간을 줄인다.
- 함수 중복 (function overloading) :
매개 변수의 개수나 타입이 서로 다른 동일한 이름의 함수들을 선언할 수 있게 한다.
- 디폴트 매개 변수 (default parameter) :
매개 변수에 값이 전달되지 않는 경우, 디폴트 값이 전달되도록 함수를 선언할 수 있게 한다.
- 참조(reference) 와 참조 변수 :
변수에 별명을 붙여 변수 공간을 같이 사용할 수 있는 참조의 개념을 도입한다.
- 참조에 의한 호출(call by reference) :
함수 호출시 참조를 전달할 수 있게 한다.
- new와 delete 연산자 :
동적 메모리 할당, 해제를 위한 new, delete 연산자를 도입한다.
- 연산자 재정의 (operator overloading) :
기존의 연산자에 새로운 연산을 정의할 수 있게 한다.
- 제네릭 함수의 클래스 (generics) :
함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킬 수 있게 한다.

3. C++의 객체 지향 특성

C++는 객체 지향 언어로서 다음과 같은 객체 지향적인 특성을 가지고 있다.

1) 객체와 캡슐화 (Encapsulation)
캡슐화는 데이터를 캡슐로 싸서 외부의 접근으로부터 데이터를 보호하는 개체 지향 특성이다. 
C++에서 캡슐의 역할을 하는 것이 클래스이며 class 키워드를 이요앟여 작성한다. 클래스는 객체를 정의하는 틀이며, 객체는 클래스라는 틀에서 생겨난 실체(instance)이다. 
C++ 클래스는 멤버 변수들과 멤버 함수들로 이루어지며, 멤버들은 캡슐 외부에 공개하거나(public), 보이지 않게(private) 선언할 수 있다. 이중 공개된 멤버들만이 외부 객체들이 접근할 수 있다. 
C++ 프로그램 개발 시, 멤버 변수들은 외부에 보이지 않게 선언하여 외부에 노출시키지 않는 것이 좋다.
대신 일부 멤버 함수들을 외부에 공개하여, 이 멤버 함수를 통해서 멤버 변수에 간접적으로 접근하게 한다.

다음 예시 코드를 통해서 이 개념을 확실히 잡아보도록 하자.

class Circle {
private:
int radius; //반지름 값
public:
Circle(int r) { radius = r; }
double getArea() { return 3.14 * radius * radius }
};

2) 상속성 (Inheritance)
객체 지향 언어에서 상속이란, 자식이 부모로부터 유산을 물려받는 개념이라기보다는, 자식이 부모의 유전자를 물려받는 것과 유사하다. 
C++에서 상속은 객체를 정의하는 클래스 사이에 상속 관계를 두어, 자식 클래스의 객체가 생성될 때 자식 클래스에 선언된 멤버뿐 아니라 부모 클래스에 선언된 멤버들도 함께 가지고 탄생하게 한다. 
상속은 구현된 코드의 재사용성을 높여서 소프트웨어 생산성을 높인다.
다음 예제는 상속 관계로 선언된 3개의 클래스를 나타낸다. 
MobilePhone(휴대 전화기) 클래스는 Phone(전화기) 클래스의 기능을 물려받고, MusicPhone(음악 기능 전화기) 클래스는 MobilePhone 클래스의 기능을 물려받는다.

class Phone {
void call();
void receive();
}

class MobilePhone : public Phone { //Phone 클래스를 상속 받음
void connectWireless();
void rechanrge();
}

class MusicPhone : public MobilePhone { //MovilePhone 클래스를 상속 받음 (자동으로 Phone 클래스도 상속 받음)
void downloadMusic();
void play();
}

3) 다형성 (Polymorphism)

다형성은 하나의 기능이 겨우에 따라 서로 다르게 보이거나 다르게 작동하는 현상을 일컫는다. 
다형성의 한 예로서 다하기 연산자(+)를 보자, + 연산자는 정수 덧셈 뿐만이 아니라 문자열의 연결(concatenation), 객체 더하기 등 피연사자에 따라 서로 다른 연산이 이루어질 수 있다. 
이를 C++에서는 연산자 중복 (operator overloading)이라고 부른다.
또한, 같은 이름의 함수가 매개 변수의 개수나 타입이 다르면 서로 다른 함수로 인식되는 함수 중복(function overloading)도 다형성의 하나이다. 
다음 3개의 함수 add()는 C++에서 서로 다른 함수로 다루어진다.

int add(int a, int b) { return a + b; }
int add(int a, int b, int c) { return a + b + c; }
double add(int a, double d) { return a + d; }

C++에서 다형성은 상속 관계에서도 나타난다. 
예를 들어, 닭, 개, 그리고 고양이라는 3개의 클래스가 동물 클래스를 상속받는다고 할 때, 동물 클래스에 선언되어 있는 "소리내기"라는 메소드를 각 자식 클래스들이 자신의 특성에 맞게 구현하게 될 것이다. 
개는 "멍멍"이라고 소리를 낼 것이고, 고양이는 "야옹", 그리고 닭은 "꼬끼오"라고 소리를 낼 것이다. 모두 동물 클래스의 "소리내기" 함수이지만, 다 다른 소리를 내고 있다. 이것이 바로 상속이 가져오는 다형성의 특징이다. 
같은 클래스를 상속받더라도, 그 후에 자신에게 더 알맞은 방식으로 재구현을 할 수 있기 때문이다.
