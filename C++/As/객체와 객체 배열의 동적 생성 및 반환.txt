1. 객체의 동적 생성 및 반환

기본 타입 변수와 마찬가지로, new와 delete를 이용하여 객체를 동적으로 생성하고 반환할 수 있다.
- new를 이용한 객체의 동적 생성과 생성자
다음은 new 연산자를 이용하여 객체를 동적 생성하는 구문이다.
클래스_이름 *포인터_변수 = new 클래스_이름; //기본 생성자 호출
클래스_이름 *포인터_변수 = new 클래스_이름(생성자_매개_변수_리스트); //매개 변수 있는 생성자 호출
new는 클래스 크기의 메모리를 할당받아 객체를 생성하며, 이때 생성자를 호출한다. 앞의 첫 번째 형식의 경우기본 생성자가 호출되며, 두 번째의 경우 매개 변수를 가진 생성자가 호출된다.
- delete를 이용한 객체 반환과 소멸자
동적으로 생성된 객체는 객체에 대한 '포인터_변수'를 이용하여 다음과 같이 반환한다.
delete 포인터_변수;
delete 사용 시 '포인터_변수'는 반드시 new를 이용하여 동적 할당받은 메모리의 주소이어야 한다. 동적 할당받은 메모리의 주소가 아니거나 이미 반환한 주소를 다시 반환할 경우에는 실행 오류가 발생된다.
delete가 실행되면, 객체를 반환하기 직전에 객체의 소멸자가 실행된다. (소멸자 실행 후 할당된 메모리 반환)

2. 객체 배열의 동적 생성 및 반환

new와 delete를 이용하면 객체 배열을 동적 생성하고 반환할 수 있다.
- 객체 배열의 동적 생성과 생성자
new를 이요앟여 객체 배열을 동적으로 생성하는 구문은 다음과 같다.
클래스_이름 *포인터_변수 = new 클래스_이름 [배열_크기];
기본 타입의 배열과 마찬가지로, 객체 배열의 동적 생성을 할 때에도 다음과 같은 구문은 컴파일 오류를 가져온다.
클래스_이름 *포인터_변수 = new 클래스_이름 [배열_크기] (생성자_배개변수); //구문 오류. 컴파일 오류
- 객체 배열의 사용
동적으로 생성된 객체 배열은 보통 객체 배열처럼 사용한다. 예를 들면 다음과 같다.
#include <iostream>
using namespace std;
Circle *pArray = new Circle[3]; //객체 배열의 동적 생성
pArray[0].setRadius(10); //배열의 첫 번째 객체의 setRadius() 멤버 함수 호출
pArray[1].setRadius(20); //배열의 두 번째 객체의 setRadius() 멤버 함수 호출
pArray[2]setRadius(30); //배열의 세 번째 객체의 setRadius() 멤버 함수 호출
for (int i = 0; i < 3; i++)
cout << pArray[i].getArea() << endl; //배열의 i 번째 객체의 getArea() 멤버 함수 호출
- 배열의 반환과 소멸자
delete 연산자를 이용하여 동적으로 할당받은 배열을 반환하는 형식은 다음과 같다.
delete [] 포인터_변수; //포인터 변수가 가리키는 배열을 반환한다.
delete 연산자를 이용해서 객체 배열을 반환하게 되면, 객체 배열의 가장 마지막 객체의 소멸자가 실행되고 끝에서부터 하나씩 자신의 소멸자를 실행시킨다. 그렇게 객체 배열의 첫 번째 객체의 소멸자까지 실행되면 할당된 메모리를 반환한다.

3. 동적으로 할당받은 메모리는 반드시 반환해야 하는가?

힙(heap)은 응용프로그램들이 실행 중에 할당받아 사용하는 시스템 메모리이다. 한 프로그램이 많은 메모리를 할당받는다면, 힙 메모리가 부족하여 다른 프로그램이 할당받을 수 없는 상황이 발생할 수 있다. 동적으로 할당받은 메모리는 필요 없을 때 힙에 반환하여 다른 프로그램이 메모리를 할당받을 수 있게 하는 것이 바람직하다. 그러나 다행스럽게도 new를 이용하여 할당받은 메모리는 그 프로그램이 종료할 때 자동으로 힙에 반환된다.
- 동적 메모리 할당과 메모리 누수 (memory leak)
동적으로 할당받은 메모리의 주소를 잃어버려 힙에 반활할 수 없게 되면 메모리 누수가 발생한다. 메모리 누수가 계속 발생하여 힙의 크기가 줄어들게 되면, 실행 중에 메모리를 할당받을 수 없는 심각한 상황이 발생할 수 있다. 물론, 응용프로그램을 종료시키고 다시 실행시키면 누수된 메모리는 다시 힙에 반환되어지지만, 이 방식은 절대 해결책이라고 볼 수 없다. 따라서, 메모리를 동적으로 할당할 경우에는 반드시 해당 메모리에 저장된 내용을 다 사용하고 나면 할당된 메모리를 반환하도록 하자.



